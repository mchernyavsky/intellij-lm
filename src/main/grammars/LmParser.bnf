{
    parserClass = "org.lm.lang.parser.LmParser"

    implements = 'org.lm.psi.ext.LmCompositeElement'
    extends = 'org.lm.psi.ext.LmCompositeElementImpl'

    elementTypeHolderClass = "org.lm.psi.LmElementTypes"

    elementTypeClass = "org.lm.psi.LmCompositeElementType"
    tokenTypeClass = "org.lm.psi.LmTokenType"

    psiClassPrefix = "Lm"
    psiImplClassSuffix = "Impl"
    psiPackage = "org.lm.psi"
    psiImplPackage = "org.lm.psi.impl"

    generateTokenAccessors = true

    tokens = [
        LPAREN     = '('
        RPAREN     = ')'
        LBRACE     = '{'
        RBRACE     = '}'

        ASSIGN     = '='
        DOT        = '.'

        ADD        = '+'
        SUB        = '-'
        MUL        = '*'
        DIV        = '/'

        MODULE_KW  = 'module'
        IMPORT_KW  = 'import'
        INCLUDE_KW = 'include'

        DEF_KW     = 'def'

        FUN_KW     = 'fun'
        FIX_KW     = 'fix'

        LET_KW     = 'let'
        LETREC_KW  = 'letrec'
        LETPAR_KW  = 'letpar'
        IN_KW      = 'in'

        IFZ_KW     = 'ifz'
        THEN_KW    = 'then'
        ELSE_KW    = 'else'

        LINE_COMMENT = "regexp:#[^\r\n]*"
    ]

    extends("module|variable|function|binding") = definition
}

program ::= statement*

statement ::= command | definition

command ::= (IMPORT_KW | INCLUDE_KW) qualifiedId

definition ::= module
    | variable
    | function {
    implements = "org.lm.psi.ext.LmNamedElement"
    mixin = "org.lm.psi.ext.LmDefinitionMixin"
}

module ::= MODULE_KW definitionId LBRACE definition* RBRACE {
    stubClass = "org.lm.psi.stubs.LmModuleStub"
    elementTypeFactory = "org.lm.psi.stubs.StubImplementationsKt.factory"
}

variable ::=  DEF_KW definitionId ASSIGN expression {
    stubClass = "org.lm.psi.stubs.LmVariableStub"
    elementTypeFactory = "org.lm.psi.stubs.StubImplementationsKt.factory"
}

function ::= FUN_KW definitionId LBRACE expression RBRACE
    | FIX_KW definitionId LBRACE expression RBRACE {
    stubClass = "org.lm.psi.stubs.LmFunctionStub"
    elementTypeFactory = "org.lm.psi.stubs.StubImplementationsKt.factory"
}

expression ::= qualifiedId
    | (LET_KW | LETREC_KW | LETPAR_KW) binding* IN_KW expression
    | IFZ_KW expression THEN_KW expression (ELSE_KW expression)?
    | LPAREN expression expression RPAREN
    | LPAREN expression (ADD | SUB | MUL | DIV) expression RPAREN
    | INT

binding ::= definitionId ASSIGN expression

definitionId ::= ID {
    implements = "org.lm.psi.ext.LmReferenceElement"
    mixin = "org.lm.psi.ext.LmDefinitionIdImplMixin"
}

qualifiedId ::= ID (DOT ID)* {
    implements = "org.lm.psi.ext.LmReferenceElement"
    mixin = "org.lm.psi.ext.LmQualifiedIdImplMixin"
}
